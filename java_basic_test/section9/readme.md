## 상속

객체지향 프로그래밍의 핵심 요소 (중요)

용어 정리
* 부모 클래스 (슈퍼 클래스) : 상속을 통하여 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
* 자식 클래스 (서브 클래스) : 부모 클래스로부터 필드와 메서드를 상속받는 클래스 


단순히 기능을 물려받는 행위라고 생각할수있지만 다른 부분이 분명히 있다

상속 관계에서 만약 새로운 인스턴스를 생성한다고 한다고 생각해보자

이러면 상속받은 클래스만 인스턴스가 생성된다고 생각하겠지만 아니다.

부모 클래스와 자식클래스 둘다 새로운 인스턴스가 생성되는것이다.

주소 값으로는 x001 이런식으로 하나가 있찌만 실제로는 두가지 클래스 정보가 공존하는것이다.

상속이라하여 부모의 필드와 메서드만 물려받는것이 아닌것이다.

### 굉장히 중요한 개념정리

1. 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
2. 상속 관계의 객체를 호출할 때 대상 타입을 정해야한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
3. 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.


@override 실수 방지? 상위 클래스의 기능을 오버라이드를 할려고할때 제대로 오버라이드 했는지 확인하게 해주는 친절한 친구 자주 애용하자.

오버라이드를 사용했다면 상위클래스에서 찾지않고 자식 클래스에서 찾아 호출


여기서 착각되는것 

오버로딩(Overloading) 과 오버라이딩(Overriding) 은 무슨차이 인가..

이름이 너무 비슷해서 매번 햇깔리는 용어다

메서드 오버로딩 : 메서드 이름이 같으며 매개변수가 다른 메서드를 여러개 정의 하는것 이것을 메서드 오버로딩 이라고 하고
음 오버로딩을 그냥 직역으로 번역하면 과적 이라는 뜻을 가지는데 과하게 물건(파라미터)를 담았다고 생각 하기로 하였다. 따라서 같은 이름의 메서드를 
여러가지 로 정의 했다고 이해 해보자

메서드 오버라이딩 : 메서드 오버라이딩은 하위(자식) 클래스에서 상위(부모) 클래스의 메서드를 다시 재정의 한다고 생각하면 될것같다
나는 이걸 보자마자 유명한 밈 중 하나인 아버지 왕위를 계승중입니다 가 떠올랐다 .. 부모의 기능(왕위)를 물려받지만 자기의 왕위로 부모와는 다른 
통치를 할것이다.. 라는 생각이 들기에 나는 이렇게 외우기로 하였다. 다시 정리해 보자면 부모의 기능을 넘어 기존 기능을 새로운 기능으로 덮어버린다고 이해해보자
상속관계 에서는 기존 기능을 뒤엎는다(다시 정의) 라고 이해하면 된다 

실무에서는 메서드 오버라이딩 , 메서드 재정의 둘다 사용한다고 한다.

개인적으로 오버로딩이 조금 더 어려운것같다.

## 메서드 오버라이딩 조건

메서드 오버라이딩을 하기위해선 까다로운 조건이 있다고 한다..
역시 왕위를 계승하는건 어려운것인가 ?
지금은 단순히 부모 메서드와 같은 메서드를 오버라이딩을 할 수 있다 라고 생각하자

### 오버라이딩을 하기 위한 조건 ❗️

1. 메서드 이름 :  메서드 이름이 같아야한다.
2. 메서드 파라미터 : 파라미터 타입 , 순서 , 개수가 같아야 한다.
3. 반환 타입 : 반환 타입이 같아야 한다.
4. 접근 제어자 : 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보자 더 제한적이어서는 안된다. 예를 들어 , 상위 클래스 의 메서드가
protected로 선언되어 있으면 하위 클래스에서 이를 public 또는 protected로 오버라이드 할 수 있지만 private 또는 default로 오버라이드 할 순 없다
5. 예외 : 오버라이딩 메서드는 상위 클래스의 메서드 보다 더 많은 체크 예외를 throws로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외
또는 하위 타입의 예외는 선언 할 수 있다. 예외를 학습해보도록하자..!
6. static , final , private : 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
    - static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다고 생각된다.
    - final 메서드는 재정의를 금지한다.
    - private 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오버라이딩 할 수 없다.
7. 생성자 오버라이딩 : 생성자는 오버라이딩 할 수 없다.

## super

하위 클래스와 상위 클래스에 이름이 같은 변수나 메서드가 있다고 생각해보자

ex : 


parents class

int value

valueplus()


child class

int value

@override
valueplus()
이럴 경우 호출을 하게되면 자식클래스에서 먼저 찾게 되어 부모 클래스에 있는 기능을 사용하지 못하는데

이때 부모 클래스를 가져와 줄수있는 기능이 super() 라는 녀석이다 굉장히 효자라고 생각한다


this : 현재 자신을 가르키는것
super : 부모를 가르키는것

